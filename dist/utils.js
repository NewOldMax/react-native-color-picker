"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHsv = toHsv;
exports.fromHsv = fromHsv;
exports.createPanResponder = createPanResponder;
exports.rotatePoint = rotatePoint;
const react_native_1 = require("react-native");
const tinycolor2_1 = __importDefault(require("tinycolor2"));
/**
 * Converts color to hsv representation.
 * @param {string} color any color represenation - name, hexa, rgb
 * @return {object} { h: number, s: number, v: number } object literal
 */
function toHsv(color) {
    return (0, tinycolor2_1.default)(color).toHsv();
}
/**
 * Converts hsv object to hexa color string.
 * @param {object} hsv { h: number, s: number, v: number } object literal
 * @return {string} color in hexa representation
 */
function fromHsv(hsv) {
    return (0, tinycolor2_1.default)(hsv).toHexString();
}
const fn = () => true;
/**
 * Simplified pan responder wrapper.
 */
function createPanResponder({ onStart = fn, onMove = fn, onEnd = fn, }) {
    return react_native_1.PanResponder.create({
        onStartShouldSetPanResponder: fn,
        onStartShouldSetPanResponderCapture: fn,
        onMoveShouldSetPanResponder: fn,
        onMoveShouldSetPanResponderCapture: fn,
        onPanResponderTerminationRequest: fn,
        onPanResponderGrant: (evt, state) => {
            return onStart({ x: evt.nativeEvent.pageX, y: evt.nativeEvent.pageY }, evt, state);
        },
        onPanResponderMove: (evt, state) => {
            return onMove({ x: evt.nativeEvent.pageX, y: evt.nativeEvent.pageY }, evt, state);
        },
        onPanResponderRelease: (evt, state) => {
            return onEnd({ x: evt.nativeEvent.pageX, y: evt.nativeEvent.pageY }, evt, state);
        },
    });
}
/**
 * Rotates point around given center in 2d.
 * Point is object literal { x: number, y: number }
 * @param {point} point to be rotated
 * @param {number} angle in radians
 * @param {point} center to be rotated around
 * @return {point} rotated point
 */
function rotatePoint(point, angle, center = { x: 0, y: 0 }) {
    // translation to origin
    const transOriginX = point.x - center.x;
    const transOriginY = point.y - center.y;
    // rotation around origin
    const rotatedX = transOriginX * Math.cos(angle) - transOriginY * Math.sin(angle);
    const rotatedY = transOriginY * Math.cos(angle) + transOriginX * Math.sin(angle);
    // translate back from origin
    const normalizedX = rotatedX + center.x;
    const normalizedY = rotatedY + center.y;
    return {
        x: normalizedX,
        y: normalizedY,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFjQSxzQkFFQztBQU9ELDBCQUVDO0FBWUQsZ0RBcUNDO0FBVUQsa0NBc0JDO0FBMUdELCtDQUlxQjtBQUNyQiw0REFBa0M7QUFJbEM7Ozs7R0FJRztBQUNILFNBQWdCLEtBQUssQ0FBQyxLQUFhO0lBQ2pDLE9BQU8sSUFBQSxvQkFBUyxFQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFBO0FBQ2pDLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLEdBQWE7SUFDbkMsT0FBTyxJQUFBLG9CQUFTLEVBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUE7QUFDckMsQ0FBQztBQVFELE1BQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQTtBQUNyQjs7R0FFRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLEVBQ2pDLE9BQU8sR0FBRyxFQUFFLEVBQ1osTUFBTSxHQUFHLEVBQUUsRUFDWCxLQUFLLEdBQUcsRUFBRSxHQUtYO0lBQ0MsT0FBTywyQkFBWSxDQUFDLE1BQU0sQ0FBQztRQUN6Qiw0QkFBNEIsRUFBRSxFQUFFO1FBQ2hDLG1DQUFtQyxFQUFFLEVBQUU7UUFDdkMsMkJBQTJCLEVBQUUsRUFBRTtRQUMvQixrQ0FBa0MsRUFBRSxFQUFFO1FBQ3RDLGdDQUFnQyxFQUFFLEVBQUU7UUFDcEMsbUJBQW1CLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDbEMsT0FBTyxPQUFPLENBQ1osRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEVBQ3RELEdBQUcsRUFDSCxLQUFLLENBQ04sQ0FBQTtRQUNILENBQUM7UUFDRCxrQkFBa0IsRUFBRSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUNqQyxPQUFPLE1BQU0sQ0FDWCxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsRUFDdEQsR0FBRyxFQUNILEtBQUssQ0FDTixDQUFBO1FBQ0gsQ0FBQztRQUNELHFCQUFxQixFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3BDLE9BQU8sS0FBSyxDQUNWLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxFQUN0RCxHQUFHLEVBQ0gsS0FBSyxDQUNOLENBQUE7UUFDSCxDQUFDO0tBQ0YsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixXQUFXLENBQ3pCLEtBQWMsRUFDZCxLQUFhLEVBQ2IsU0FBa0IsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFFaEMsd0JBQXdCO0lBQ3hCLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQTtJQUN2QyxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUE7SUFFdkMseUJBQXlCO0lBQ3pCLE1BQU0sUUFBUSxHQUNaLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ2pFLE1BQU0sUUFBUSxHQUNaLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBRWpFLDZCQUE2QjtJQUM3QixNQUFNLFdBQVcsR0FBRyxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQTtJQUN2QyxNQUFNLFdBQVcsR0FBRyxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQTtJQUN2QyxPQUFPO1FBQ0wsQ0FBQyxFQUFFLFdBQVc7UUFDZCxDQUFDLEVBQUUsV0FBVztLQUNmLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgR2VzdHVyZVJlc3BvbmRlckV2ZW50LFxuICBQYW5SZXNwb25kZXIsXG4gIFBhblJlc3BvbmRlckdlc3R1cmVTdGF0ZSxcbn0gZnJvbSBcInJlYWN0LW5hdGl2ZVwiXG5pbXBvcnQgdGlueWNvbG9yIGZyb20gXCJ0aW55Y29sb3IyXCJcblxuaW1wb3J0IHsgSHN2Q29sb3IsIFBvaW50MkQgfSBmcm9tIFwiLi90eXBlSGVscGVyc1wiXG5cbi8qKlxuICogQ29udmVydHMgY29sb3IgdG8gaHN2IHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGFueSBjb2xvciByZXByZXNlbmF0aW9uIC0gbmFtZSwgaGV4YSwgcmdiXG4gKiBAcmV0dXJuIHtvYmplY3R9IHsgaDogbnVtYmVyLCBzOiBudW1iZXIsIHY6IG51bWJlciB9IG9iamVjdCBsaXRlcmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hzdihjb2xvcjogc3RyaW5nKTogSHN2Q29sb3Ige1xuICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpXG59XG5cbi8qKlxuICogQ29udmVydHMgaHN2IG9iamVjdCB0byBoZXhhIGNvbG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBoc3YgeyBoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyIH0gb2JqZWN0IGxpdGVyYWxcbiAqIEByZXR1cm4ge3N0cmluZ30gY29sb3IgaW4gaGV4YSByZXByZXNlbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhzdihoc3Y6IEhzdkNvbG9yKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRpbnljb2xvcihoc3YpLnRvSGV4U3RyaW5nKClcbn1cblxudHlwZSBQYW5SZXNwb25kZXJDYWxsYmFjayA9IChcbiAgeyB4LCB5IH06IFBvaW50MkQsXG4gIGV2ZW50OiBHZXN0dXJlUmVzcG9uZGVyRXZlbnQsXG4gIHN0YXRlOiBQYW5SZXNwb25kZXJHZXN0dXJlU3RhdGVcbikgPT4gYm9vbGVhbjtcblxuY29uc3QgZm4gPSAoKSA9PiB0cnVlXG4vKipcbiAqIFNpbXBsaWZpZWQgcGFuIHJlc3BvbmRlciB3cmFwcGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFuUmVzcG9uZGVyKHtcbiAgb25TdGFydCA9IGZuLFxuICBvbk1vdmUgPSBmbixcbiAgb25FbmQgPSBmbixcbn06IHtcbiAgb25TdGFydD86IFBhblJlc3BvbmRlckNhbGxiYWNrO1xuICBvbk1vdmU/OiBQYW5SZXNwb25kZXJDYWxsYmFjaztcbiAgb25FbmQ/OiBQYW5SZXNwb25kZXJDYWxsYmFjaztcbn0pIHtcbiAgcmV0dXJuIFBhblJlc3BvbmRlci5jcmVhdGUoe1xuICAgIG9uU3RhcnRTaG91bGRTZXRQYW5SZXNwb25kZXI6IGZuLFxuICAgIG9uU3RhcnRTaG91bGRTZXRQYW5SZXNwb25kZXJDYXB0dXJlOiBmbixcbiAgICBvbk1vdmVTaG91bGRTZXRQYW5SZXNwb25kZXI6IGZuLFxuICAgIG9uTW92ZVNob3VsZFNldFBhblJlc3BvbmRlckNhcHR1cmU6IGZuLFxuICAgIG9uUGFuUmVzcG9uZGVyVGVybWluYXRpb25SZXF1ZXN0OiBmbixcbiAgICBvblBhblJlc3BvbmRlckdyYW50OiAoZXZ0LCBzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIG9uU3RhcnQoXG4gICAgICAgIHsgeDogZXZ0Lm5hdGl2ZUV2ZW50LnBhZ2VYLCB5OiBldnQubmF0aXZlRXZlbnQucGFnZVkgfSxcbiAgICAgICAgZXZ0LFxuICAgICAgICBzdGF0ZVxuICAgICAgKVxuICAgIH0sXG4gICAgb25QYW5SZXNwb25kZXJNb3ZlOiAoZXZ0LCBzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIG9uTW92ZShcbiAgICAgICAgeyB4OiBldnQubmF0aXZlRXZlbnQucGFnZVgsIHk6IGV2dC5uYXRpdmVFdmVudC5wYWdlWSB9LFxuICAgICAgICBldnQsXG4gICAgICAgIHN0YXRlXG4gICAgICApXG4gICAgfSxcbiAgICBvblBhblJlc3BvbmRlclJlbGVhc2U6IChldnQsIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gb25FbmQoXG4gICAgICAgIHsgeDogZXZ0Lm5hdGl2ZUV2ZW50LnBhZ2VYLCB5OiBldnQubmF0aXZlRXZlbnQucGFnZVkgfSxcbiAgICAgICAgZXZ0LFxuICAgICAgICBzdGF0ZVxuICAgICAgKVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogUm90YXRlcyBwb2ludCBhcm91bmQgZ2l2ZW4gY2VudGVyIGluIDJkLlxuICogUG9pbnQgaXMgb2JqZWN0IGxpdGVyYWwgeyB4OiBudW1iZXIsIHk6IG51bWJlciB9XG4gKiBAcGFyYW0ge3BvaW50fSBwb2ludCB0byBiZSByb3RhdGVkXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtwb2ludH0gY2VudGVyIHRvIGJlIHJvdGF0ZWQgYXJvdW5kXG4gKiBAcmV0dXJuIHtwb2ludH0gcm90YXRlZCBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlUG9pbnQoXG4gIHBvaW50OiBQb2ludDJELFxuICBhbmdsZTogbnVtYmVyLFxuICBjZW50ZXI6IFBvaW50MkQgPSB7IHg6IDAsIHk6IDAgfVxuKSB7XG4gIC8vIHRyYW5zbGF0aW9uIHRvIG9yaWdpblxuICBjb25zdCB0cmFuc09yaWdpblggPSBwb2ludC54IC0gY2VudGVyLnhcbiAgY29uc3QgdHJhbnNPcmlnaW5ZID0gcG9pbnQueSAtIGNlbnRlci55XG5cbiAgLy8gcm90YXRpb24gYXJvdW5kIG9yaWdpblxuICBjb25zdCByb3RhdGVkWCA9XG4gICAgdHJhbnNPcmlnaW5YICogTWF0aC5jb3MoYW5nbGUpIC0gdHJhbnNPcmlnaW5ZICogTWF0aC5zaW4oYW5nbGUpXG4gIGNvbnN0IHJvdGF0ZWRZID1cbiAgICB0cmFuc09yaWdpblkgKiBNYXRoLmNvcyhhbmdsZSkgKyB0cmFuc09yaWdpblggKiBNYXRoLnNpbihhbmdsZSlcblxuICAvLyB0cmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICBjb25zdCBub3JtYWxpemVkWCA9IHJvdGF0ZWRYICsgY2VudGVyLnhcbiAgY29uc3Qgbm9ybWFsaXplZFkgPSByb3RhdGVkWSArIGNlbnRlci55XG4gIHJldHVybiB7XG4gICAgeDogbm9ybWFsaXplZFgsXG4gICAgeTogbm9ybWFsaXplZFksXG4gIH1cbn1cbiJdfQ==